---
title: "[Baekjoon] 9465번 스티커"
categories: 
- Baekjoon
tags:
- Dynamic Programming
toc: true   #Table Of Contents 목차 
use_math: true
toc_sticky: true
comments: true
---

## 문제

상근이의 여동생 상냥이는 문방구에서 스티커 2n개를 구매했다. 스티커는 그림 (a)와 같이 2행 n열로 배치되어 있다. 상냥이는 스티커를 이용해 책상을 꾸미려고 한다.

상냥이가 구매한 스티커의 품질은 매우 좋지 않다. 스티커 한 장을 떼면, 그 스티커와 변을 공유하는 스티커는 모두 찢어져서 사용할 수 없게 된다. 즉, 뗀 스티커의 왼쪽, 오른쪽, 위, 아래에 있는 스티커는 사용할 수 없게 된다.

![img](https://www.acmicpc.net/upload/images/sticker.png)

모든 스티커를 붙일 수 없게된 상냥이는 각 스티커에 점수를 매기고, 점수의 합이 최대가 되게 스티커를 떼어내려고 한다. 먼저, 그림 (b)와 같이 각 스티커에 점수를 매겼다. 상냥이가 뗄 수 있는 스티커의 점수의 최댓값을 구하는 프로그램을 작성하시오. 즉, 2n개의 스티커 중에서 점수의 합이 최대가 되면서 서로 변을 공유 하지 않는 스티커 집합을 구해야 한다.

위의 그림의 경우에 점수가 50, 50, 100, 60인 스티커를 고르면, 점수는 260이 되고 이 것이 최대 점수이다. 가장 높은 점수를 가지는 두 스티커 (100과 70)은 변을 공유하기 때문에, 동시에 뗄 수 없다.

## 입력

첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스의 첫째 줄에는 n (1 ≤ n ≤ 100,000)이 주어진다. 다음 두 줄에는 n개의 정수가 주어지며, 각 정수는 그 위치에 해당하는 스티커의 점수이다. 연속하는 두 정수 사이에는 빈 칸이 하나 있다. 점수는 0보다 크거나 같고, 100보다 작거나 같은 정수이다. 

## 출력

각 테스트 케이스 마다, 2n개의 스티커 중에서 두 변을 공유하지 않는 스티커 점수의 최댓값을 출력한다.

## 예제

**Example 1:**

```
Input: 
2
5
50 10 100 20 40
30 50 70 10 60
7
10 30 10 50 100 20 40
20 40 30 50 60 20 80
Output: 
260
290
```

## 조건

> 시간 제한 : 1초
>
> 메모리 제한 : 256 MB

## 풀이과정

### 내 풀이

개인적으로는 [포도주 시식](https://leeyeongeol.github.io/baekjoon/Baekjoon-2156%EB%B2%88-%ED%8F%AC%EB%8F%84%EC%A3%BC-%EC%8B%9C%EC%8B%9D/)문제와 비슷하다고 생각했다. 입력을 보기 dp계산하기 편하게 바꾸어주고 풀었다. dp 테이블을 업데이트할 때 주의할 점은 두가지였다.

첫째로, 뗀 스티커의 왼쪽은 사용할 수 없게 된다. 이를 점화식으로 나타내면 다음과 같다.
$$
dp[i][0] = dp[i-1][1] + arr[i][0]\\
dp[i][1] = dp[i-1][0] + arr[i][1]
$$
현재 위치가 $i$이고 스티커 위를 0이라 하고 아래를 1이라 하면 $dp[i][0]$을 업데이트하기 위해서는 위치 $i-1$에서 아래를 사용해야 하므로 $dp[i-1][1]$에 다가 현재 스티커인 $arr[i][0]$을 더해준다.

둘째로, 스티커 떼는 것을 건너가는 경우이다. 첫째에서는 무조건 번갈아가면서 떼도록 되어있다. 하지만 예제에서 볼 수 확인할 수 있듯이 첫번째 예제의 답은 50 + 50 + 100 + 60으로 260이 되는데 20과 10의 라인은 건너 뛰도록 되어있다. 그 이유는 그전까지 200이 최대이고 10을 뗀다면 다음에 40을 떼야해서 260보다 작아지기 때문이다. 따라서 $i-2$의 경우도 고려해주어야 한다. 이를 점화식으로 나타내면 다음과 같다.
$$
max(dp[i-2][0], dp[i-2][1]) + arr[i][0]\\
max(dp[i-2][0], dp[i-2][1]) + arr[i][1]
$$
중간을 건너뛰는 경우에는 스티커가 찢어지는 경우를 고려하지 않아도 되기 때문에 $dp[i-2][0], dp[i-2][1]$ 양쪽 다 고려하여 큰 값을 구하고 거기에 현재 스티커값을 더해준다.

이렇게 첫째 경우와 둘째 경우를 합쳐서 최대가 되는 경우를 계속 업데이트하면 답을 구할 수 있다.

```python
# 테스트 케이스 입력
testcase = int(input())

for _ in range(testcase):
    # 2줄로 주어지는 스티커 개수 n
    n = int(input())
    arr1 = list(map(int, input().split()))
    arr2 = list(map(int, input().split()))
    arr = []
    
    # 스티커 정리
    for i in range(n):
        arr.append([arr1[i], arr2[i]])

    # dp 테이블 정의
    dp = [[0] * 2 for _ in range(n)]
    dp[0][0] = arr[0][0]
    dp[0][1] = arr[0][1]

    dp[1][0] = dp[0][1] + arr[1][0]
    dp[1][1] = dp[0][0] + arr[1][1]
    
    # dp 테이블 업데이트 및 결과 출력
    for i in range(2, n):
        dp[i][0] = max(dp[i-1][1] + arr[i][0], max(dp[i-2][0], dp[i-2][1] )+ arr[i][0])
        dp[i][1] = max(dp[i-1][0] + arr[i][1], max(dp[i-2][0], dp[i-2][1] )+ arr[i][1])
    print(max(dp[n-1]))
```
